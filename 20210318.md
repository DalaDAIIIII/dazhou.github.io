[TOC]

# 20210318笔记

## 深拷贝与浅拷贝

```js
var a =[1,2,3];
var b =[{a:1},{b:1},{c:1}];
var c = [].concat(a);
var d = [].concat(b);

function change(){
	c[0] = 6;
	console.log(a);
	

	d[0].a = 3;
	console.log(b);
	return ;

}
function deepClone(obj) {
    if(!obj && typeof obj !== 'object'){
        return;
    }
    var newObj= toString.call(obj) === '[object Array]' ? [] : {};
    for (var key in obj) {
        if (obj[key] && typeof obj[key] === 'object') {
            newObj[key] = deepClone(obj[key]);
        } else {
            newObj[key] = obj[key];
        }
    }
    return newObj;
}
function fff(){
var e = deepClone(b);
	e[0].a = 99;
	console.log(e);
	console.log(b);
}
```



## 去除字符串中所有空格

**1**、使用replace

```js
var str1 = "hello word";

function strfun(str){
var kk = str.replace(/\s+/g,"");
	console.log(kk);
}
```

**2**、使用split(),与join(): 如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割,

```
str.split(" ").join("");
```

**3**、String.trim()

```
trim()是去掉首尾空格
```

**4**、或者replaceAll(" +",""); 去掉所有空格

```
去除字符串中最后一个指定字符

str.replace('//g')


正则表达式复习

[ABC]：匹配字符串中所有A,B,C字符

[^ABC]: 匹配除了A,B,C之外所有字符

[A-Z]匹配所有大写字符
```

## ES6的箭头函数

箭头函数本身没有自己的 this，只能通过父级作用域来获取到this，也不能作为构造函数使用。

```js
const test1 = () => {
  const t = () => {
    console.log(this);
  }
  t();
}
test1(); // -> window
new test1(); // -> 报错 因为箭头函数不能当做构造函数来使用 TypeError: test2 is not a constructor

const test2 = function () {  
  test2.t = () => { 
    console.log(this);  
  }  
  test2.t();
}
new test2(); // -> window 箭头函数的this是通过父级来获取的

```

箭头函数不存在arguments 只能通过spread运算符把参数手机起来

```js
const test = (...args) => {  
  console.log(args); // -> []  
  console.log(arguments); // -> 报错 ReferenceError: arguments is not defined
}
test();

```

## ES6类的写法

```js
将下面代码转换成 ES6 class 的写法;
(function () {
  var c = 1;  
  function Test () { 
   console.log(c);  
  }  
  Test.prototype.a = function () {
    Test.b();  
  } 
  Test.b = function () {
   console.log('I am a static function of Test constructor');  
  }  
  window.Test = Test;
})();

// class 就相当于构造函数的语法糖
const Test = (() => {
  let c = 1;
  class Test {
    constructor () {
      console.log(c);
    }
    a () {
      Test.b();
    }
    static b () {
      console.log('I am a static function of Test constructor');
    }
  }
})();

```

## 异步promise

```js
const promise = new Promise((resolve, reject) => {
  console.log(1);  
  resolve();  
  console.log(2);
})
promise.then(() => {  
  console.log(3);
})
console.log(4);
// 1 2 4 3

```

Promise的`executor`函数，在`new`创建promise实例时会被立即调用，所以 1 和 2 依次打印，然后`resolve()`将Promise的状态由`pending ->Fulfilled`，之后会调用成功的回调函数。`.then`执行成功的回调函数，会被放到微任务的事件队列中，等待主线程空闲后在执行。然后打印 4，主线程空闲，将微任务队列中的任务推进主线程中执行，所以最后打印 3。

```js
const promise = new Promise((resolve, reject) => {
  console.log(1);  
  resolve();  
  setTimeout(() => {
    console.log(2);  
  });
})
.then(() => {
  console.log(3);
})
console.log(4);
// 1 4 3 2

```



这里的和上述情况差不多，就是一个计时器 2 最后打印的区别。因为JS 异步代码中，分为宏任务与微任务，他们分别有自己的任务队列，这里就存在一个优先级的问题，当主线程空闲时间，会先检查微任务队列，然后再走宏任务队列。而计时器就属于宏任务，所以最后打印。

## for in 与 for of 的区别

for in 遍历的是索引（键名） for of遍历的是值

for in 可以遍历对象  且可遍历自身及原型以上可枚举的属性

for of 只能遍历具有迭代器接口的数据，如果想遍历对象可以使用`Object.keys()`将对象的键名生成一个数组

for in不会遍历空数组，稀松数组会跳过空位

```js
// 一条解构与一个条打印语句 打印出12121234
const obj = {  
  a: {    
    b: 1,    
    c: 2,    
    d: { 
      e: 1, 
      f: 2, 
      g: [1, 2, 3, 4]
    }  
  }
};

const {b, c, d: {e, f, g: [h, i, j, k]}} = obj.a
console.log(b, c, e, f, h, i, j, k);

```

## 数组的几种遍历方法

**for in & for of** : 参照上一小节内容



**forEach**()：遍历数组且不能break;

```js
arr = [1,2,3,4,5,6];
arr.forEach(res=>{
console.log(res);
})
```

**fliter**(): 对数组进行遍历返回符合条件的值

```js
arr = [1,2,3,4,5,6];
cosnt myArr =  arr.fliter(res=>{
return res >3;
})
```

**every**():遍历所有值，全部符合条件为true,否者为false

```js
arr = [1,2,3,4,5,6];
const isRight =  arr.every(res=>{
res>5;
})
console.log(isRight)//false;
```

**some**()：遍历至少有一个符合条件返回true，都不符合返回false

```js
arr = [1,2,3,4,5,6];
const isRight =  arr.some(res=>{
res>5;
})
console.log(isRight)//true;
```

**map**()：对数组每个值遍历，完成后返回一个新的数组

```js
arr = [1,2,3,4,5,6];
const isRight =  arr.map(res=>{
res+1;
})
console.log(isRight)//[2,3,4,5,6,7];
```

**reduce**()：对数组遍历累加或累乘每次返回上一次的计算结果

```js
arr = [1,2,3,4,5,6];
//prev 上次回调返回的值或者初始值init，cur当前处理的数组元素，index当前元素索引值，原数组
const value = arr.reduce((prev,cur,index,arr)=>{
     return prev+cur ;//prev*cur
 })
console.log(isRight)//true;
//求最大项
var max = arr.reduce(function (prev, cur) {
    return Math.max(prev,cur);
});
// 数组去重
var newArr = arr.reduce(function (prev, cur) {
    prev.indexOf(cur) === -1 && prev.push(cur);
    return prev;
},[])
```

**reduceRight**():从数组末尾开始累加累乘；

方法同上

**findIndex**()：发现符合条件的值返回其索引值没有返回-1

```js
arr = [1,2,3,4,5,6];
cons  index = arr.finIndex(3);//2
```



