```

```

## 函数

高阶函数：

函数作为参数，函数作为返回值,常用的高阶函数

```js
// map
function map(array, fn) {
	let results = []
  for (const value of array) {
  	result.push(fn(value))
  }
  return results
}
```



### 闭包

##### 产生闭包的背景

- 全局变量容易被污染，为了减少全局变量，将参数定义在函数体内
- 函数体内的参数，外界无法使用，所以在函数内返回一个新的函数，并将参数放在其中供外部调用

##### 闭包的基础认知

- 闭包：在函数中被返回的函数
- 解决的问题：使外部可以调用函数内部的变量
- 问题：闭包会导致变量不会被GC回收，所以不要滥用闭包





### 纯函数

- 一个函数的返回值，只依赖于入参，并且在执行过程中，没有副作用（函数的执行过程中，不会改变外部的变量）
- 函数式编程，不会保留计算中间的结果，所以变量是不可变的（无状态的）
- 优点：

1. 1. 可缓存，当计算过大时，可const a = 。。。 将数据缓存
   2. 可测试
   3. 多线程环境下并行操作共享的内存数据很可能会出现意外情况
   4. 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数

- 副作用：外部变量影响函数的运行结果

```js
// 不纯的函数【外界值改变，会影响相同入参的函数输出值】
let min = 18;
function checkAge (age) {
	return age >= min
}

// 纯函数（有硬编码，后续可以通过柯里化解决）【只受入参影响】
function checkAge (age) {
	let min = 18;
  return age >= min
}
```

### 函数柯里化

解决硬编码问题，

原理：当一个函数有多个参数的时候，先传递一部分参数调用它（这部分参数以后永远不变）然后返回一个新的函数调用剩余的参数，返回结果

作用：可将任意多元函数转为一元函数。

```js
// 简单的柯里化理解
function curry(min) {
	return function(age) {
		return age <= min；
	}
}
let info = curry(18); // 提取并储存一个参数，方便后面函数调用时，不用反复传入相同参数
info(16) // true
info(20) // false


let curry = (min) => (age => age <= min);

curry(18)(16); // true 
```

函数组合

函子